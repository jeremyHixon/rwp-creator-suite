# WordPress Plugin Codebase Analysis Context

## Overview
This context file enables comprehensive analysis of WordPress plugin codebases against established coding standards, architectural patterns, and best practices. It evaluates PHP, JavaScript, CSS, and build configurations for compliance with modern WordPress development guidelines.

## Analysis Scope

### Core Areas
- **PHP Code Standards** - WordPress coding standards, security, performance
- **Block Development** - Gutenberg blocks, modern JavaScript practices
- **Architecture Patterns** - Service-based modules, client-heavy architecture
- **State Management** - localStorage strategies, user preferences, fallbacks
- **API Design** - REST endpoints, authentication, caching
- **Testing Coverage** - PHP/JS unit tests, integration tests
- **Build System** - Webpack, asset optimization, deployment
- **Style Isolation** - Block styling, theme compatibility, Tailwind/DaisyUI

### File Patterns to Analyze

#### PHP Files
- All `.php` files in plugin root, includes, modules, migrations directories
- Class files, function files, template files
- Migration scripts and database handlers

#### JavaScript Files
- All `.js`, `.jsx`, `.ts`, `.tsx` files in assets, src, blocks directories
- Block editor components and frontend applications
- Module files and utility scripts

#### Configuration Files
- `package.json`, `webpack.config.js`, `tailwind.config.js`
- `composer.json`, `phpunit.xml`, `jest.config.js`
- Build and deployment configuration files

#### Build Assets
- Generated files in build and dist directories
- Compiled CSS and JavaScript assets
- Asset manifests and optimization outputs

## Analysis Framework

### 1. PHP Code Standards Analysis

#### Naming Convention Requirements
- **Classes**: Must use underscores with title case formatting
- **Functions**: Must use plugin prefix with lowercase underscores
- **Variables**: Must use lowercase with underscores
- **Files**: Must use hyphens with lowercase formatting
- **Prefixing**: All functions, classes, and globals must use consistent plugin prefix

#### Security Practice Requirements
- **Input Sanitization**: All user input must be sanitized using WordPress functions
- **Output Escaping**: All output must be escaped using appropriate WordPress functions
- **Nonce Verification**: All forms and AJAX requests must verify nonces
- **Capability Checks**: All administrative functions must check user capabilities
- **Database Security**: All database queries must use prepared statements

#### WordPress Integration Requirements
- **Hook Usage**: Must use WordPress hooks instead of direct function calls
- **WordPress Functions**: Must use WordPress functions over custom implementations
- **Plugin Lifecycle**: Must properly handle activation, deactivation, and uninstall
- **Internationalization**: All user-facing strings must be translatable

### 2. Block Development Standards

#### Block Structure Requirements
- **Modern Registration**: Must use `block.json` for block metadata
- **Component Separation**: Must separate edit and save components
- **Asset Organization**: Must organize styles and scripts properly
- **WordPress Scripts**: Must use `@wordpress/scripts` for build process

#### Container Block Pattern Requirements
- **Simple Containers**: Blocks must serve as simple mounting points for apps
- **Minimal PHP Logic**: PHP rendering must be minimal, app logic in JavaScript
- **Progressive Enhancement**: Must work without JavaScript for basic functionality
- **App Mounting**: Complex functionality must mount into block containers

### 3. Architecture Analysis

#### Service-Based Module Requirements
- **Module Interface**: All modules must implement consistent interface pattern
- **Dependency Injection**: Must use service container for dependency management
- **Lazy Loading**: Modules must load conditionally based on requirements
- **Hook Registration**: Must register WordPress hooks through module system

#### Client-Heavy Pattern Requirements
- **API-First Design**: Backend must primarily serve API endpoints
- **JavaScript Applications**: Complex logic must reside in JavaScript layer
- **State Management**: Must implement proper client-side state management
- **Server Minimization**: PHP must handle API, authentication, and preferences only

#### Cache-Friendly Requirements
- **Guest Optimization**: Must aggressively cache content for non-logged-in users
- **User-Specific Caching**: Must implement appropriate caching for authenticated users
- **Static Generation**: Must generate static content when possible
- **Cache Headers**: Must set appropriate cache headers for different user states

### 4. State Management Requirements

#### Storage Strategy Requirements
- **localStorage Primary**: Must use localStorage as primary storage mechanism
- **Graceful Degradation**: Must provide fallbacks when localStorage unavailable
- **Warning Systems**: Must warn users about storage limitations
- **Server Sync**: Must sync user preferences to server for logged-in users only
- **No Guest Storage**: Must never store guest data in database

#### User Transition Requirements
- **Seamless Migration**: Must smoothly transition guest state to user state on login
- **Data Merging**: Must properly merge guest data with server-stored preferences
- **Cleanup Procedures**: Must clean up temporary guest data appropriately
- **State Persistence**: Must maintain state across page reloads and sessions

### 5. API Design Requirements

#### Endpoint Structure Requirements
- **WordPress REST API**: Must use WordPress REST API as foundation
- **Consistent Naming**: Must follow consistent endpoint naming conventions
- **Proper Methods**: Must use appropriate HTTP methods for operations
- **Version Management**: Must implement API versioning strategy

#### Response Format Requirements
- **Standardized Structure**: All responses must follow consistent format structure
- **Error Handling**: Must implement consistent error response patterns
- **Success Responses**: Must provide meaningful success response data
- **Metadata Inclusion**: Must include relevant metadata in responses

#### Security Requirements
- **Permission Callbacks**: All endpoints must implement proper permission checks
- **Nonce Verification**: State-changing operations must verify nonces
- **Rate Limiting**: Must implement appropriate rate limiting measures
- **Input Validation**: All endpoint inputs must be validated and sanitized

### 6. Testing Coverage Requirements

#### PHP Testing Requirements
- **PHPUnit Integration**: Must use PHPUnit for PHP unit testing
- **WordPress Mocking**: Must properly mock WordPress functions in tests
- **Integration Testing**: Must include integration tests with WordPress
- **Database Testing**: Must test database operations and migrations

#### JavaScript Testing Requirements
- **Jest Configuration**: Must use Jest with proper WordPress environment setup
- **Component Testing**: Must test all JavaScript components and modules
- **State Testing**: Must test state management functionality
- **API Testing**: Must test API client functionality and error handling

### 7. Build System Requirements

#### Modern Tooling Requirements
- **WordPress Scripts**: Must use `@wordpress/scripts` as primary build tool
- **Asset Optimization**: Must implement proper asset optimization for production
- **Development Workflow**: Must provide efficient development environment
- **Version Management**: Must implement proper asset versioning and cache busting

#### Deployment Requirements
- **Environment Detection**: Must properly detect and handle different environments
- **Migration System**: Must implement database migration system
- **Health Monitoring**: Must include plugin health check functionality
- **Automated Testing**: Must integrate automated testing in deployment pipeline

### 8. Style Isolation Requirements

#### Block Style Containment Requirements
- **Complete Isolation**: Block styles must not affect theme or other blocks
- **Prefix Usage**: Must use consistent prefixes for all utility classes
- **CSS Reset**: Must reset inherited styles within block boundaries
- **Container Queries**: Must use container queries for responsive design within blocks

#### Theme Compatibility Requirements
- **Universal Compatibility**: Must work with any WordPress theme
- **No Theme Dependencies**: Must not rely on theme-specific styles or functions
- **Light Theme Consistency**: Must use light theme design consistently
- **Minimalistic Approach**: Must maintain clean, simple aesthetic design

## Analysis Evaluation Criteria

### Critical Compliance Areas
- **Security Implementation**: All security practices must be properly implemented
- **WordPress Standards**: Must adhere to all WordPress coding standards
- **Architecture Patterns**: Must follow established architectural guidelines
- **Performance Optimization**: Must implement all performance best practices

### Warning Level Issues
- **Inconsistent Patterns**: Deviations from established patterns
- **Missing Tests**: Inadequate test coverage for functionality
- **Optimization Opportunities**: Areas where performance could be improved
- **Documentation Gaps**: Missing or inadequate code documentation

### Enhancement Opportunities
- **Code Organization**: Areas where structure could be improved
- **Feature Completeness**: Missing functionality that would improve user experience
- **Developer Experience**: Opportunities to improve development workflow
- **Maintenance Considerations**: Areas that could improve long-term maintainability

## Red Flags and Violations

### Immediate Action Required
- **Security Vulnerabilities**: Unescaped output, unsanitized input, missing nonces
- **WordPress Violations**: Use of deprecated functions, non-standard implementations
- **Architecture Violations**: Heavy block logic, server storage for guests, missing fallbacks
- **Performance Issues**: Unoptimized queries, large bundle sizes, missing caching

### Architecture Pattern Violations
- **Block Complexity**: Business logic in block components instead of separate apps
- **Storage Violations**: Database storage for guest users or temporary data
- **API Inconsistencies**: Non-standard response formats or error handling
- **State Management Issues**: Missing localStorage fallbacks or improper user transitions

### Development Practice Issues
- **Testing Deficiencies**: Missing or inadequate test coverage
- **Build Configuration Problems**: Outdated tools, missing optimizations
- **Style Isolation Failures**: Theme conflicts, styling leaks, design inconsistencies
- **Documentation Shortfalls**: Missing inline documentation or setup instructions

## Analysis Output Requirements

### Summary Assessment
- Overall compliance percentage with guidelines
- Count of critical issues requiring immediate attention
- Architecture alignment assessment
- Security status evaluation

### Detailed Findings Organization
- **By Severity**: Critical, warning, enhancement levels
- **By Category**: Security, architecture, performance, standards
- **By File/Component**: Specific violations in context
- **With Priorities**: Clear indication of what to address first

### Recommendation Structure
- **Action Required**: Specific steps to address each finding
- **Implementation Guidance**: Direction on how to properly implement fixes
- **Priority Level**: Clear indication of urgency and importance
- **Expected Impact**: Description of improvement after implementation

## Compliance Verification

### Standards Adherence Checklist
- WordPress coding standards compliance verification
- Security best practices implementation confirmation
- Architecture pattern adherence validation
- Performance optimization implementation check

### Quality Assurance Requirements
- Test coverage adequacy assessment
- Build process optimization verification
- Style isolation effectiveness validation
- Documentation completeness evaluation

### Long-term Maintenance Considerations
- Code organization sustainability assessment
- Scalability pattern implementation verification
- Update and maintenance pathway evaluation
- Developer onboarding documentation adequacy

This analysis framework ensures comprehensive evaluation of WordPress plugin codebases against established guidelines while providing clear direction for achieving compliance and improving code quality.